/*
 * CS 575: Project #3
 * File: Solver.java 
 */
package org.aghannam.bpcp;

import java.util.ArrayList;

/**
 * This class implements a solver for the Bounded Post's Correspondence Problem
 * (BPCP).
 * <p>
 * The solver is based on a semi-naive breadth-first search (BFS) technique for
 * finding a solution. For any given input instance that has a solution, only
 * the first matching sequence is returned. Because it is based on BFS, hard
 * instances with deep solutions take an extended amount of time. However, as
 * the search is bounded by some k, the solver will eventually halt, whether or
 * not a solution has been found.
 * 
 * @author Ahmed Ghannam (amalghannam@crimson.ua.edu)
 */
public class Solver {
	/**
	 * The top string of a BPCP pair.
	 */
	private String top;

	/**
	 * The bottom string of a BPCP pair.
	 */
	private String bottom;

	/**
	 * The size of the input instance (i.e. the number of pairs in the list).
	 */
	private int n;

	/**
	 * Holds the possible search sequences generated by the BFS algorithm.
	 */
	private ArrayList<String> permutations = new ArrayList<String>();

	/**
	 * The current iteration in the search process.
	 */
	private int step = 0;

	/**
	 * Constructs a new instance of the BPCP solver, given the input list of
	 * pairs.
	 * 
	 * @param instance
	 *            the input list of pairs
	 */
	public Solver(ArrayList<Pair> instance) {
		this.n = instance.size();
		this.permutations.add(computePermutation(1));
	}

	/**
	 * Attempts to find a solution for a given BPCP instance using breadth-first
	 * search.
	 * <p>
	 * If a solution is found, it is returned as a sequence of positive
	 * integers, each corresponding to a pair from the input instance. The
	 * length of this sequence will always be less than or equal to the value of
	 * k. For instances with no solution on the specified k, this method
	 * terminates with an appropriate message. The search can take an extended
	 * amount of time depending primarily on the difficulty of the input
	 * instance.
	 * 
	 * @param instance
	 *            the input list of pairs of strings for which to search for a
	 *            solution
	 * @param k
	 *            the maximum possible length of a potential solution sequence
	 */
	public void solveBpcp(ArrayList<Pair> instance, int k) {
		if (k <= 0) {
			System.err.println("\nInvalid input: k must be larger than zero. Process terminated...");
			System.exit(1);
		}

		System.out.println("\nSearching for a matching sequence. This may take a while...");

		boolean foundSolution = false;
		int sequence[] = tryNext(step);

		while (sequence.length <= k) {
			top = "";
			bottom = "";

			if (sequence.length > k) {
				break; // no solution of length <= k found
			}

			for (int i = 0; i < sequence.length; i++) {
				top = top.concat(instance.get(sequence[i] - 1).top);
				bottom = bottom.concat(instance.get(sequence[i] - 1).bottom);
			}

			if (top.equals(bottom)) {
				foundSolution = true;
				break; // terminate the search as soon as a matching sequence is
						// found
			} else {
				step++;
				permutations.add(computePermutation(step));
				sequence = tryNext(step);
			}
		}

		if (foundSolution == true) {
			System.out.print("\nSolution found! A valid sequence is: ");
			showSequence(sequence);
			return; // successful halt
		}

		System.out.println("\nDone searching. No solution found for the given instance on k = " + k + ".");
	}

	/**
	 * Displays the current search sequence. (Should only be called when a
	 * solution is found.)
	 * 
	 * @param sequence
	 *            the current generated sequence of integers
	 */
	private void showSequence(int[] sequence) {
		for (int i = 0; i < sequence.length; i++) {
			System.out.print(sequence[i] + " ");
		}
	}

	/**
	 * Returns the next computed sequence, which represents a potential solution
	 * for an input instance.
	 * 
	 * @param step
	 *            the current iteration of the search
	 * @return the next sequence to try and find a match with
	 */
	private int[] tryNext(int step) {
		String str = permutations.get(step);
		int[] nextSequence = new int[str.length()];
		try {
			for (int i = 0; i < str.length(); i++) {
				nextSequence[i] = Integer.parseInt(String.valueOf(str.charAt(i)));
			}
		} catch (NumberFormatException e) {
			System.err.println("\nError generating a search sequence. Consider revising your input.");
			System.exit(2);
		}
		return nextSequence;
	}

	/**
	 * Computes the permutation induced by the visit order of a BFS traversal
	 * step.
	 * 
	 * @param iteration
	 *            the current iteration in the search
	 * @return the computed BFS permutation
	 */
	private String computePermutation(int iteration) {
		if (iteration < n + 1) {
			return Character.toString((char) (iteration + 48));
		} else {
			if (iteration % n == 0) {
				return computePermutation((iteration / n) - 1) + computePermutation(((iteration - 1) % n + 1));
			} else {
				return computePermutation(iteration / n) + computePermutation(iteration % n);
			}
		}
	}
}
